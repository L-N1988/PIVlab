function [methodinfo,structs,enuminfo,ThunkLibName]=pco_recorder_mfile
%PCO_RECORDER_MFILE Create structures to define interfaces found in 'sc2_cammatlab'.

%This function was generated by loadlibrary.m parser version  on Fri Jun  6 15:09:54 2025
%perl options:'sc2_cammatlab.i -outfile=pco_recorder_mfile.m -thunkfile=PCO_CAM_RECORDER_thunk_pcwin64.c -header=sc2_cammatlab.h pco_recorder_export.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'PCO_CAM_RECORDER_thunk_pcwin64');
% void PCO_RecorderGetVersion ( int * iMajor , int * iMinor , int * iPatch , int * iBuild ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderGetVersion'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'int32Ptr', 'int32Ptr', 'int32Ptr', 'int32Ptr'};fcnNum=fcnNum+1;
% int PCO_RecorderSaveImage ( void * pImgBuf , uint16_t wWidth , uint16_t wHeight , const char * cFileType , bool bIsBitmap , const char * szFilePath , bool bOverwrite , PCO_METADATA_STRUCT * strMetadata ); 
fcns.thunkname{fcnNum}='int32voidPtruint16uint16cstringboolcstringboolvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderSaveImage'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint16', 'uint16', 'cstring', 'bool', 'cstring', 'bool', 'PCO_METADATA_STRUCTPtr'};fcnNum=fcnNum+1;
% int PCO_RecorderSaveOverlay ( void * pImgBufR , void * pImgBufG , void * pImgBufB , uint16_t wWidth , uint16_t wHeight , const char * cFileType , const char * szFilePath , bool bOverwrite , PCO_METADATA_STRUCT * strMetadata ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtruint16uint16cstringcstringboolvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderSaveOverlay'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'voidPtr', 'uint16', 'uint16', 'cstring', 'cstring', 'bool', 'PCO_METADATA_STRUCTPtr'};fcnNum=fcnNum+1;
% int PCO_RecorderResetLib ( bool bSilent ); 
fcns.thunkname{fcnNum}='int32boolThunk';fcns.name{fcnNum}='PCO_RecorderResetLib'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'bool'};fcnNum=fcnNum+1;
% int PCO_RecorderCreate ( void ** phRec , PCO_cam_ptr_List * CamArr , const uint32_t * dwImgDistributionArr , uint16_t wArrLength , uint16_t wRecMode , const char * szDrive , uint32_t * dwMaxImgCountArr ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtruint16uint16cstringvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderCreate'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtrPtr', 'PCO_cam_ptr_ListPtr', 'uint32Ptr', 'uint16', 'uint16', 'cstring', 'uint32Ptr'};fcnNum=fcnNum+1;
% int PCO_RecorderDelete ( void * phRec ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='PCO_RecorderDelete'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
% int PCO_RecorderInit ( void * phRec , uint32_t * dwImgCountArr , uint16_t wArrLength , uint16_t wType , uint16_t wNoOverwrite , const char * szFilePath , uint16_t * wRamSegmentArr ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint16uint16uint16cstringvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderInit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint32Ptr', 'uint16', 'uint16', 'uint16', 'cstring', 'uint16Ptr'};fcnNum=fcnNum+1;
% int PCO_RecorderCleanup ( void * phRec , void * phCam ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderCleanup'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% int PCO_RecorderGetSettings ( void * phRec , void * phCam , uint32_t * dwRecMode , uint32_t * dwMaxImgCount , uint32_t * dwReqImgCount , uint16_t * wWidth , uint16_t * wHeight , uint16_t * wMetadataLines ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrvoidPtrvoidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderGetSettings'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'uint32Ptr', 'uint32Ptr', 'uint32Ptr', 'uint16Ptr', 'uint16Ptr', 'uint16Ptr'};fcnNum=fcnNum+1;
% int PCO_RecorderStartRecord ( void * phRec , void * phCam ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderStartRecord'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% int PCO_RecorderStopRecord ( void * phRec , void * phCam ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderStopRecord'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% int PCO_RecorderSetAutoExposure ( void * phRec , void * phCam , bool bAutoExpState , uint16_t wSmoothness , uint32_t dwMinExposure , uint32_t dwMaxExposure , uint16_t wExpBase ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrbooluint16uint32uint32uint16Thunk';fcns.name{fcnNum}='PCO_RecorderSetAutoExposure'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'bool', 'uint16', 'uint32', 'uint32', 'uint16'};fcnNum=fcnNum+1;
% int PCO_RecorderSetAutoExpRegions ( void * phRec , void * phCam , uint16_t wRegionType , uint16_t * wRoiX0Arr , uint16_t * wRoiY0Arr , uint16_t wArrLength ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint16voidPtrvoidPtruint16Thunk';fcns.name{fcnNum}='PCO_RecorderSetAutoExpRegions'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'uint16', 'uint16Ptr', 'uint16Ptr', 'uint16'};fcnNum=fcnNum+1;
% int PCO_RecorderSetCompressionParams ( void * phRec , void * phCam , PCO_Recorder_CompressionParams * strCompressionParams ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderSetCompressionParams'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'PCO_Recorder_CompressionParamsPtr'};fcnNum=fcnNum+1;
% int PCO_RecorderGetStatus ( void * phRec , void * phCam , bool * bIsRunning , bool * bAutoExpState , uint32_t * dwLastError , uint32_t * dwProcImgCount , uint32_t * dwReqImgCount , bool * bBuffersFull , bool * bFIFOOverflow , uint32_t * dwStartTime , uint32_t * dwStopTime ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrvoidPtrvoidPtrvoidPtrvoidPtrvoidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderGetStatus'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'boolPtr', 'boolPtr', 'uint32Ptr', 'uint32Ptr', 'uint32Ptr', 'boolPtr', 'boolPtr', 'uint32Ptr', 'uint32Ptr'};fcnNum=fcnNum+1;
% int PCO_RecorderGetImageAddress ( void * phRec , void * phCam , uint32_t dwImgIdx , void ** wImgBuf , uint16_t * wWidth , uint16_t * wHeight , uint32_t * dwImgNumber ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint32voidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderGetImageAddress'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'uint32', 'voidPtrPtr', 'uint16Ptr', 'uint16Ptr', 'uint32Ptr'};fcnNum=fcnNum+1;
% int PCO_RecorderCopyImage ( void * phRec , void * phCam , uint32_t dwImgIdx , uint16_t wRoiX0 , uint16_t wRoiY0 , uint16_t wRoiX1 , uint16_t wRoiY1 , void * wImgBuf , uint32_t * dwImgNumber , PCO_METADATA_STRUCT * strMetadata , PCO_TIMESTAMP_STRUCT * strTimestamp ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint32uint16uint16uint16uint16voidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderCopyImage'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'uint32', 'uint16', 'uint16', 'uint16', 'uint16', 'voidPtr', 'uint32Ptr', 'PCO_METADATA_STRUCTPtr', 'PCO_TIMESTAMP_STRUCTPtr'};fcnNum=fcnNum+1;
% int PCO_RecorderCopyAverageImage ( void * phRec , void * phCam , uint32_t dwStartIdx , uint32_t dwStopIdx , uint16_t wRoiX0 , uint16_t wRoiY0 , uint16_t wRoiX1 , uint16_t wRoiY1 , void * wImgBuf ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint32uint32uint16uint16uint16uint16voidPtrThunk';fcns.name{fcnNum}='PCO_RecorderCopyAverageImage'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'uint32', 'uint32', 'uint16', 'uint16', 'uint16', 'uint16', 'voidPtr'};fcnNum=fcnNum+1;
% int PCO_RecorderCopyImageCompressed ( void * phRec , void * phCam , uint32_t dwImgIdx , uint16_t wRoiX0 , uint16_t wRoiY0 , uint16_t wRoiX1 , uint16_t wRoiY1 , uint8_t * bImgBuf , uint32_t * dwImgNumber , PCO_METADATA_STRUCT * strMetadata , PCO_TIMESTAMP_STRUCT * strTimestamp ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint32uint16uint16uint16uint16voidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='PCO_RecorderCopyImageCompressed'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'uint32', 'uint16', 'uint16', 'uint16', 'uint16', 'uint8Ptr', 'uint32Ptr', 'PCO_METADATA_STRUCTPtr', 'PCO_TIMESTAMP_STRUCTPtr'};fcnNum=fcnNum+1;
% int PCO_RecorderExportImage ( void * phRec , void * phCam , uint32_t dwImgIdx , const char * szFilePath , bool bOverwrite ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtruint32cstringboolThunk';fcns.name{fcnNum}='PCO_RecorderExportImage'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'uint32', 'cstring', 'bool'};fcnNum=fcnNum+1;
structs.PCO_Buflist.packing=1;
structs.PCO_Buflist.members=struct('sBufNr_1', 'int16', 'ZZwAlignDummy_1', 'uint16', 'dwStatusDll_1', 'uint32', 'dwStatusDrv_1', 'uint32', 'sBufNr_2', 'int16', 'ZZwAlignDummy_2', 'uint16', 'dwStatusDll_2', 'uint32', 'dwStatusDrv_2', 'uint32', 'sBufNr_3', 'int16', 'ZZwAlignDummy_3', 'uint16', 'dwStatusDll_3', 'uint32', 'dwStatusDrv_3', 'uint32', 'sBufNr_4', 'int16', 'ZZwAlignDummy_4', 'uint16', 'dwStatusDll_4', 'uint32', 'dwStatusDrv_4', 'uint32', 'sBufNr_5', 'int16', 'ZZwAlignDummy_5', 'uint16', 'dwStatusDll_5', 'uint32', 'dwStatusDrv_5', 'uint32', 'sBufNr_6', 'int16', 'ZZwAlignDummy_6', 'uint16', 'dwStatusDll_6', 'uint32', 'dwStatusDrv_6', 'uint32', 'sBufNr_7', 'int16', 'ZZwAlignDummy_7', 'uint16', 'dwStatusDll_7', 'uint32', 'dwStatusDrv_7', 'uint32', 'sBufNr_8', 'int16', 'ZZwAlignDummy_8', 'uint16', 'dwStatusDll_8', 'uint32', 'dwStatusDrv_8', 'uint32');
structs.PCO_METADATA_STRUCT.packing=1;
structs.PCO_METADATA_STRUCT.members=struct('wSize', 'uint16', 'wVersion', 'uint16', 'bIMAGE_COUNTER_BCD', 'uint8#4', 'bIMAGE_TIME_US_BCD', 'uint8#3', 'bIMAGE_TIME_SEC_BCD', 'uint8', 'bIMAGE_TIME_MIN_BCD', 'uint8', 'bIMAGE_TIME_HOUR_BCD', 'uint8', 'bIMAGE_TIME_DAY_BCD', 'uint8', 'bIMAGE_TIME_MON_BCD', 'uint8', 'bIMAGE_TIME_YEAR_BCD', 'uint8', 'bIMAGE_TIME_STATUS', 'uint8', 'wEXPOSURE_TIME_BASE', 'uint16', 'dwEXPOSURE_TIME', 'uint32', 'dwFRAMERATE_MILLIHZ', 'uint32', 'sSENSOR_TEMPERATURE', 'int16', 'wIMAGE_SIZE_X', 'uint16', 'wIMAGE_SIZE_Y', 'uint16', 'bBINNING_X', 'uint8', 'bBINNING_Y', 'uint8', 'dwSENSOR_READOUT_FREQUENCY', 'uint32', 'wSENSOR_CONV_FACTOR', 'uint16', 'dwCAMERA_SERIAL_NO', 'uint32', 'wCAMERA_TYPE', 'uint16', 'bBIT_RESOLUTION', 'uint8', 'bSYNC_STATUS', 'uint8', 'wDARK_OFFSET', 'uint16', 'bTRIGGER_MODE', 'uint8', 'bDOUBLE_IMAGE_MODE', 'uint8', 'bCAMERA_SYNC_MODE', 'uint8', 'bIMAGE_TYPE', 'uint8', 'wCOLOR_PATTERN', 'uint16', 'wCAMERA_SUBTYPE', 'uint16', 'dwEVENT_NUMBER', 'uint32', 'wIMAGE_SIZE_X_Offset', 'uint16', 'wIMAGE_SIZE_Y_Offset', 'uint16', 'bREADOUT_MODE', 'uint8');
structs.PCO_TIMESTAMP_STRUCT.packing=1;
structs.PCO_TIMESTAMP_STRUCT.members=struct('wSize', 'uint16', 'dwImgCounter', 'uint32', 'wYear', 'uint16', 'wMonth', 'uint16', 'wDay', 'uint16', 'wHour', 'uint16', 'wMinute', 'uint16', 'wSecond', 'uint16', 'dwMicroSeconds', 'uint32');
structs.PCO_Recorder_CompressionParams.packing=1;
structs.PCO_Recorder_CompressionParams.members=struct('dGainK', 'double', 'dDarkNoise_e', 'double', 'dDSNU_e', 'double', 'dPRNU_pct', 'double', 'dLightSourceNoise_pct', 'double');
structs.PCO_cam_ptr_List.packing=1;
structs.PCO_cam_ptr_List.members=struct('cam_ptr1', 'voidPtr', 'cam_ptr2', 'voidPtr', 'cam_ptr3', 'voidPtr', 'cam_ptr4', 'voidPtr');
methodinfo=fcns;